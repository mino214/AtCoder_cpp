# AtCoder メモ：隣接 swap + 区間和クエリ（BIT / Fenwick Tree）

## 問題概要

長さ `N` の配列 `A` に対して、`Q` 個のクエリを順に処理する。

- **クエリ 1 x**：`A[x]` と `A[x+1]` を入れ替える（swap）
- **クエリ 2 l r**：`A[l] + A[l+1] + ... + A[r]`（区間和）を出力する

### 制約
- `N ≤ 2×10^5`
- `Q ≤ 5×10^5`

`2 l r` を毎回 for で足すと `O(NQ)` になり **TLE** する。

---

## BIT（Fenwick Tree）がなぜ動くのか

BIT（Fenwick Tree）は、配列の「部分和」を効率よく管理するためのデータ構造。  
ポイントは **`i & -i`（最下位ビット / LSB）** が「区間の長さ」を表すこと。

### 1) `i & -i` とは？

- `i` の **最下位に立っている 1 のビット**だけを取り出す演算
- 例：
  - `i = 6 (110₂)` → `i & -i = 2 (010₂)`
  - `i = 12 (1100₂)` → `i & -i = 4 (0100₂)`

これを **LSB（Least Significant Bit）** と呼ぶ。

### 2) BIT の配列 `bit[i]` は何を持っている？

**`bit[i]` は「長さ LSB の区間の合計」を持つ。**

- `LSB = i & -i`
- `bit[i]` が担当する区間は `[i - LSB + 1, i]` の和（1-indexed）

#### 例（N = 8 のとき）

| i | i (2進) | LSB = i & -i | bit[i] が持つ区間 |
|---|---------|--------------|-------------------|
| 1 | 0001    | 1            | [1, 1]            |
| 2 | 0010    | 2            | [1, 2]            |
| 3 | 0011    | 1            | [3, 3]            |
| 4 | 0100    | 4            | [1, 4]            |
| 5 | 0101    | 1            | [5, 5]            |
| 6 | 0110    | 2            | [5, 6]            |
| 7 | 0111    | 1            | [7, 7]            |
| 8 | 1000    | 8            | [1, 8]            |

「区間の長さが 1, 2, 4, 8…」のように **2 の冪**でまとまっているのがポイント。

### 3) `sum(i)`（1..i の累積和）が速い理由

`sum(i)` は次のように計算する：

```cpp
for (; i > 0; i -= i & -i) {
    ans += bit[i];
}
```

**直感**
- `bit[i]` は `[i - LSB + 1, i]` の和を持っている
- `bit[i]` を足すと「末尾のまとまった区間」が一気に計算できる
- その後 `i -= LSB` すると、「まだ足していない前の部分」に移動する

つまり、`i` を LSB 分ずつ削っていくことで、`1..i` を重ならない区間の和に分解して足している。

`i` のビットが 1 個ずつ消えていくので、回数は高々 `log N`。

### 4) `add(i, v)`（点更新）が速い理由

`A[i]` に `v` を加えたら、その値を含む区間の `bit[]` にも反映する必要がある。

```cpp
for (; i <= n; i += i & -i) {
    bit[i] += v;
}
```

**直感**
- `bit[i]` は「末尾が `i` の区間」を持つ
- `A[i]` は、末尾が `i` 以上で、かつその区間が `i` を含む `bit[...]` に影響する
- `i += LSB` で「より大きい区間（親）」へジャンプしていく

これもジャンプ回数が `log N` 程度で済む。

### 5) 区間和 `[l, r]` の計算

BIT は基本的に `sum(x) = 1..x` が得意なので、

```
rangeSum(l, r) = sum(r) - sum(l - 1)
```

で区間和を求める。

### 6) この問題との対応（なぜ swap が 2 回更新で済む？）

**クエリ 1 x** は `A[x]` と `A[x+1]` の入れ替えで、変わるのはその 2 箇所だけ。

- swap 前：`old1 = A[x]`, `old2 = A[x+1]`
- swap 後：差分を BIT に反映
    - `add(x, A[x] - old1)`
    - `add(x+1, A[x+1] - old2)`

点更新 2 回 → `O(log N)` で完了。

---

## まとめ（覚えるポイント）

- `LSB = i & -i`
- `bit[i]` は `[i - LSB + 1, i]` の和
- `sum` は `i -= LSB` で区間を削っていく
- `add` は `i += LSB` で親区間へ上がっていく
- 区間和は `sum(r) - sum(l - 1)`

---

## 失敗コード例（TLE になる）

**ポイント**：タイプ 2（区間和）を `for (j = l..r)` で毎回計算しているため `O(N)`。

```cpp
#include <iostream>
using namespace std;

int main() {
    int N;
    long M;
    
    cin >> N >> M;
    
    int A[N];
    for (int i = 0; i < N; i++)
        cin >> A[i];
    
    for (int i = 0; i < M; i++) {
        int type;
        cin >> type;
        
        if (type == 1) {
            int x;
            cin >> x;
            int temp = A[x - 1];
            A[x - 1] = A[x];
            A[x] = temp;
        } else {
            int result = 0;
            int l, r;
            cin >> l >> r;
            for (int j = l - 1; j < r; j++) {
                result += A[j];
            }
            cout << result << "\n";
        }
    }
    return 0;
}
```

**問題点**：区間和クエリが `O(N)` なので、全体で `O(NQ)` = `O(10^11)` となり TLE。

**解決策**：BIT を使って区間和を `O(log N)` で計算する。
