# 部分集合和問題 (Subset Sum Problem)

## 問題概要

N 枚のカードがあり、各カードには整数 A_i が書かれている。  
**いくつかのカードを選んで、合計がちょうど S になるか判定する。**

### 制約
- `1 ≤ N ≤ 60`
- `1 ≤ A_i ≤ 10000`
- `1 ≤ S ≤ 10000`

### 部分点
- `N ≤ 20`: 全探索で解ける → **500点**
- `N ≤ 60`: 動的計画法が必要 → **1000点 (AC)**

---

## なぜ N=20 と N=60 で解法が変わるのか？

### 全探索の計算量

各カードについて「選ぶ/選ばない」の 2 通り → **2^N 通り**

| N | 2^N | 実行可能？ |
|---|-----|-----------|
| 20 | 2^20 ≈ 10^6 |  約 100 万通り（1秒以内） |
| 60 | 2^60 ≈ 10^18 |  約 100京通り（数百万年） |

**結論**: N=20 までは全探索、N=60 は別の方法が必要

---

## 方法1: 全探索 (N ≤ 20)

### アプローチ

すべての部分集合を列挙して、合計が S になるものがあるか確認する。

### 実装方法

**bit 全探索**を使う：
- 0 から 2^N - 1 まで繰り返す
- 各数を 2 進数で表現すると、i 番目のビットが立っていれば「カード i を選ぶ」

```cpp
// 例: N=3, bit=5 (101₂) の場合
// → カード 0 と カード 2 を選ぶ

for (int bit = 0; bit < (1 << N); bit++) {
    int sum = 0;
    for (int i = 0; i < N; i++) {
        if (bit & (1 << i)) {  // i 番目のビットが立っているか
            sum += A[i];
        }
    }
    if (sum == S) {
        // 見つかった！
        return true;
    }
}
```

### 時間計算量
- `O(2^N × N)`
- N=20 の場合: `2^20 × 20 ≈ 2000万` → **通過**

---

## 方法2: 動的計画法 (N ≤ 60)

### なぜ DP が必要？

2^60 は大きすぎるが、**S ≤ 10000** という制約に注目！

**重要な観察**:
- 「どのカードを選んだか」は重要ではない
- 「今までの合計がいくつか」だけが重要

→ **同じ合計は何度も計算しなくていい**

### DP の定義

```
dp[i][j] = 最初の i 枚のカードから選んで、合計 j が作れるか (true/false)
```

- `i`: 0 〜 N (何枚目まで見たか)
- `j`: 0 〜 S (現在の合計)

### 遷移

カード i を見たとき、2 つの選択肢：

1. **選ばない**: `dp[i+1][j] = dp[i][j]`
2. **選ぶ**: `dp[i+1][j+A[i]] = dp[i][j]` (j+A[i] ≤ S の場合)

### 実装例

```cpp
bool dp[N+1][S+1];

// 初期化
dp[0][0] = true;  // 0枚で合計0は作れる

// DP テーブルを埋める
for (int i = 0; i < N; i++) {
    for (int j = 0; j <= S; j++) {
        if (!dp[i][j]) continue;  // 作れない状態はスキップ
        
        // 選ばない
        dp[i+1][j] = true;
        
        // 選ぶ
        if (j + A[i] <= S) {
            dp[i+1][j + A[i]] = true;
        }
    }
}

// 答え
if (dp[N][S]) {
    // 合計 S が作れる
}
```

### 時間計算量
- `O(N × S)`
- N=60, S=10000 の場合: `60 × 10000 = 60万` → **通過**

---

## 必要な概念まとめ

### 1. bit 全探索 (N ≤ 20)

**使うテクニック**:
- `1 << N`: 2^N を計算
- `bit & (1 << i)`: i 番目のビットが立っているか判定
- すべての部分集合を 0 〜 2^N-1 の整数で表現

**適用条件**:
- 「選ぶ/選ばない」の組み合わせ問題
- N が小さい (N ≤ 20〜25)

### 2. 動的計画法 (DP)

**使うテクニック**:
- 状態を定義: `dp[i][j]` = (i 番目まで見て、合計 j が作れるか)
- 遷移を考える: 各要素を「選ぶ/選ばない」
- メモ化: 同じ状態は 1 回だけ計算

**適用条件**:
- 部分問題に分解できる
- 状態数が少ない (N × S が 10^7 以下くらい)

### 3. 計算量の見積もり

| 手法 | 計算量 | N の上限 |
|------|--------|----------|
| bit 全探索 | O(2^N × N) | N ≤ 20 |
| DP (ナップサック型) | O(N × S) | N ≤ 1000, S ≤ 10^5 |

---

## この問題の解法選択フロー

```
N ≤ 20?
  ├─ YES → bit 全探索 (500点)
  └─ NO  → 動的計画法 (1000点)
```

**重要**: 制約を見て、どの手法が使えるか判断する力が必要！

---

## 類似問題

- **ナップザック問題**: 価値を最大化する部分集合を選ぶ
- **分割問題**: 配列を 2 つに分けて、合計を等しくできるか
- **コイン問題**: 特定の金額をコインの組み合わせで作れるか

すべて「部分集合の選び方」を考える問題 → DP が有効